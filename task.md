## **Задание 1**

[Page not found · GitHub · GitHub](https://github.com/lloppy/My-Asnova)
<br>
## **Задание 2. Singleton** 

```java
// Паттерн Singleton
```


1. UserManager реализован как синглтон, тк:
	- У нас один юзер, поэтому каждый раз мне нужно ссылаться на одно и того же юзера (объекта)
	- UserManager можно легко получить из любого места приложения
	
2. Segments реализован как синглтон, тк:
	-  Мне нужен всего один экземпляр класса
	- Удобно обращаться к константам по их названиям, удобно получать сразу все константы методом в Segments
	- Segments можно легко получить из любого места приложения
	- Я еще летом переписывала этот кусок кода, потому что изначально у меня всё хранилось в строках, которые дублировались. Сейчас дублирования переменных нет
	
3. Объекты в DataModule и NetworkModule (но не сами классы). В классах используется аннотация @Singleton в Dagger Hilt тк:
	- Hilt по умолчанию при каждом обращении будет создавать новые экземпляры, а нам нужен только один экземпляр. С аннотацией @Singleton будет создаваться один экземпляр (например в DataModule мы с помощью Retrofit создаем единственный экземпляр GroupsApi, к которому потом каждый раз будет обращаться Апи для групп во Вконтакте)

Протупила с работой в классе, пусть будет тут https://github.com/lloppy/patterns_5sem_urfu/tree/main/tasks/lessons/singleton.md


<br>

### На доп баллы, потерянные на работе в классе
> [!NOTE] На доп баллы, потерянные на работе в классе
> Что значит "Экземпляр должен расширяться путем порождения подклассов **(1)**, и клиентам нужно иметь возможность работать с расширенным экземпляром без модификации своего кода **(2)**"

**(1)** *"Экземпляр должен расширяться путем порождения подклассов ..."*

Пусть есть главный класс - **Экземпляр**, ребенок1 и ребенок2 расширяют (extends в котлин) функционал класса-родителя. 

<br>

Схема "Родитель-Экземпляр расширяется путем порождения детей-подклассов":

Экземпляр -> ребенок1 (расширение) Экземпляра

Экземпляр -> ребенок2 (расширение) Экземпляра

<br>

Пример: Сюда можно привести геом фигуры и вычисление их площади (**Shape**-родитель и *Circle: Shape()* *Square : Shape()*), или класс животные и звуки которые разные животные издают (**Animal**-родитель и *Dog : Animal()* *Cat : Animal()*).

<br>

**(2)** Пусть клиент - это функция fun Клиент() 
Пусть *Клиенту()* мы можем в аргументы "скармливать" только животных Animal. 

Вторая часть тезиса звучала как *"...Клиентам нужно иметь возможность работать с расширенным экземпляром без модификации своего кода"* - значит, что *Клиенту()*  мы должны уметь подать и Animal, и Dog, и Cat. 

Предполагаю, это нужно для фабрик в будущем

<br>

## **Задание 3. Prototype** 

```java
// Паттерн Prototype
```


<br>

## **Задание 4. Static factory method

```java
// Паттерн Static factory method
```

Изначально у меня было два раздельных класса для расписаний: с сайта ([Расписание- ASNOVA учебно-экспертный центр](https://asnova.pro/raspisanie)) и приватное (парсится из mail calendar). Чтобы создать экземпляр класса нужно было вспоминать названия этих классов, я постоянно путалась какое слово идет первым. 

Я переделала свой прошлый код, теперь создание упрощено: есть класс Schedule, к которому мы обращаемся через точку и сразу видим, какие экземпляры мы можем создать - Schedule.createPrivateSchedule() или Schedule.createSiteSchedule().

Вот так это выглядит:
- сайт:  [gcKczrEZflA.jpg](https://sun9-58.userapi.com/impg/s94rnDHbnoEU4X-FvgiZMLXCpN-p0CxKdJVRCw/gcKczrEZflA.jpg?size=997x2160&quality=96&sign=aef03a06f62a582167d6da79d90081c1&type=album)
- main calendar: [w6hTD5RImt4.jpg](https://sun9-16.userapi.com/impg/Mwzfkq43VFNBBLJBKxbMhHa3si7fyuppNLBfTQ/w6hTD5RImt4.jpg?size=997x2160&quality=96&sign=34dd928213b6122deec47561acada29b&type=album)


Также со Static factory method удобно будет дальше делать приложение, тк у меня планируется еще один вид расписания - из Firebase, который потом также добавлю в класс Schedule и сделаю под него метод Schedule.createFirebaseSchedule()


