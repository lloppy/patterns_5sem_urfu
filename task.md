## Оглавление 
- [Задание 1](#задание-1) 
- [Задание 2. Singleton](#задание-2-singleton) 
- [Задание 3. Prototype](#задание-3-prototype) 
- [Задание 4. Static factory method](#задание-4-static-factory-method)
- [Задание 5. Builder](#задание-5-builder)
- [Задание 6. Factory method](#задание-6-factory-method)


<br>

## **Задание 1**

[Проект Asnova here](https://github.com/lloppy/My-Asnova)
<br>

## **Задание 2. Singleton** 

```java
// Паттерн Singleton
```


1. UserManager реализован как синглтон, тк:
	- У нас один юзер, поэтому каждый раз мне нужно ссылаться на одно и того же юзера (объекта)
	- UserManager можно легко получить из любого места приложения
	
2. Segments реализован как синглтон, тк:
	-  Мне нужен всего один экземпляр класса
	- Удобно обращаться к константам по их названиям, удобно получать сразу все константы методом в Segments
	- Segments можно легко получить из любого места приложения
	- Я еще летом переписывала этот кусок кода, потому что изначально у меня всё хранилось в строках, которые дублировались. Сейчас дублирования переменных нет
	
3. Объекты в DataModule и NetworkModule (но не сами классы). В классах используется аннотация @Singleton в Dagger Hilt тк:
	- Hilt по умолчанию при каждом обращении будет создавать новые экземпляры, а нам нужен только один экземпляр. С аннотацией @Singleton будет создаваться один экземпляр (например в DataModule мы с помощью Retrofit создаем единственный экземпляр GroupsApi, к которому потом каждый раз будет обращаться Апи для групп во Вконтакте)

Протупила с работой в классе, пусть будет тут https://github.com/lloppy/patterns_5sem_urfu/tree/main/tasks/lessons/singleton.md


<br>

### На доп баллы, потерянные на работе в классе
> [!NOTE] На доп баллы, потерянные на работе в классе
> Что значит "Экземпляр должен расширяться путем порождения подклассов **(1)**, и клиентам нужно иметь возможность работать с расширенным экземпляром без модификации своего кода **(2)**"

**(1)** *"Экземпляр должен расширяться путем порождения подклассов ..."*

Пусть есть главный класс - **Экземпляр**, ребенок1 и ребенок2 расширяют (extends в котлин) функционал класса-родителя. 

<br>

Схема "Родитель-Экземпляр расширяется путем порождения детей-подклассов":

Экземпляр -> ребенок1 (расширение) Экземпляра

Экземпляр -> ребенок2 (расширение) Экземпляра

<br>

Пример: Сюда можно привести геом фигуры и вычисление их площади (**Shape**-родитель и *Circle: Shape()* *Square : Shape()*), или класс животные и звуки которые разные животные издают (**Animal**-родитель и *Dog : Animal()* *Cat : Animal()*).

<br>

**(2)** Пусть клиент - это функция fun Клиент() 
Пусть *Клиенту()* мы можем в аргументы "скармливать" только животных Animal. 

Вторая часть тезиса звучала как *"...Клиентам нужно иметь возможность работать с расширенным экземпляром без модификации своего кода"* - значит, что *Клиенту()*  мы должны уметь подать и Animal, и Dog, и Cat. 

Предполагаю, это нужно для фабрик в будущем

<br>

## **Задание 3. Prototype** 

```java
// Паттерн Prototype
```

Не могла придумать какую уже реализованную фичу можно было бы переделать под Prototype, поэтому делала всё с нуля.

У центра есть учебные группы. Для моего приложения учебные группы нужны для фильтрации расписания (по учебной группе).
Списка со всеми группами у заказчика нет, но есть расписание, в котором коряво написаны когда и у какой группы занятия (у заказчика просто нет шаблона по которому он составляет внутреннее расписание, поэтому *коряво*).

Prototype я реализовала для роли Админа, который сможет редактировать (делается **отредактированная копия**) название учебной группы. 


***Почему Prototype?***

У нас есть колонка со всеми спарсенными item\`ами групп, которые нужно будет редактировать Админу вручную. По нажатию на item можно его дублировать/редактировать. После сохранения, дкблированный и/или измененный item добавляется в общий лист. 

[See video of duplicating](https://drive.google.com/file/d/15a0De5vueUIzXMAtgxLqwAo6rvLtTvgC/view?usp=drive_link)

<br>

## **Задание 4. Static factory method** 

```java
// Паттерн Static factory method
```

Изначально у меня было два раздельных класса для расписаний: с сайта ([Расписание- ASNOVA учебно-экспертный центр](https://asnova.pro/raspisanie)) и приватное (парсится из mail calendar). Чтобы создать экземпляр класса нужно было вспоминать названия этих классов, я постоянно путалась какое слово идет первым. 

Я переделала свой прошлый код, теперь создание упрощено: есть класс Schedule, к которому мы обращаемся через точку и сразу видим, какие экземпляры мы можем создать - Schedule.createPrivateSchedule() или Schedule.createSiteSchedule().

Вот так это выглядит:
- сайт:  [gcKczrEZflA.jpg](https://sun9-58.userapi.com/impg/s94rnDHbnoEU4X-FvgiZMLXCpN-p0CxKdJVRCw/gcKczrEZflA.jpg?size=997x2160&quality=96&sign=aef03a06f62a582167d6da79d90081c1&type=album)
- main calendar: [w6hTD5RImt4.jpg](https://sun9-16.userapi.com/impg/Mwzfkq43VFNBBLJBKxbMhHa3si7fyuppNLBfTQ/w6hTD5RImt4.jpg?size=997x2160&quality=96&sign=34dd928213b6122deec47561acada29b&type=album)


Также со Static factory method удобно будет дальше делать приложение, тк у меня планируется еще один вид расписания - из Firebase, который потом также добавлю в класс Schedule и сделаю под него метод Schedule.createFirebaseSchedule()

<br>

## **Задание 5. Builder** 

```java
// Паттерн Builder
```

Билдер уже был реализован в моем приложении, потому что это эталон создания сложных объектов в андроиде со множеством параметров.

- `IntentSenderRequest.Builder` нужен для создания запроса на вход в аккаунт (без необходимости создания множества конструкторов)
- В `NetworkModule.kt`  используется `Retrofit.Builder` для настройки сетевых запросов. С ним легче менять параметры для запроса.
- В `CalDavClient.kt`  используется `Request.Builder` для создания HTTP-запросов
- и тд.

<br>

## **Задание 6. Factory method** 

```java
// Паттерн Factory method
```

Структура:

![[Pasted image 20241002200645.png]]


Выбрала фабричный метод для Android для обработки пуш-уведомлений с помощью Firebase Cloud Messaging (FCM) по статье [«Фабричный метод» в разработке под Android. Лучший способ обработки пушей / Хабр](https://habr.com/ru/articles/332006/)
В первый раз их подключала.


Мне нужно было сделать уведомления для ролей (учащийся, админ, гость, сотрудник).
Есть абстрактные классы `CoreNotification`(абстрактный продукт) и `CoreNotificationCreator`(абстрактный создатель) и классы реализации конкретных создателей и классы реализации конкретных продуктов (см картинку-схему)


После добавления стало легче добавлять новые типы уведомлений. 
В зависимости от типа уведомления будут создаются соответствующие классы. 
Я сдеала реализацию не для всех ролей и не для всех конкретных случаев, но теперь чтобы их добавить не нужно изменять уже имеющийся код

![[Pasted image 20241002201320.png]]


<br>


  
 [наверх](#Оглавление) 